---
layout: post
title: Reread C++ primer
description: c++ & interview
category: blog
---

(1)

``` c++
int ival(1024); //direct-initialization 直接初始化
int ival = 1024; //copy-initialization  拷贝初始化
```

(2)
初始化不是赋值

(3)
c++中变量必须且仅能定义一次，而且在使用变量之前必须定义或声明

变量的定义用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。

声明用于想程序表明变量的类型和名字。定义也是声明：当定义变量时，我们声明了它的类型和名字。

可以使用extern关键字声明变量而不定义它。

``` c++
extern int i; // declares but does not define i
int i;        // declares and defines i

```

extern声明不是定义，也不分配存储空间。事实上，它只是说明变量定义在程序的其他地方。

定义只可以出现一次，而声明可以出现多次。

(4)
因为常量定义后就不能被修改，所以定义时必须初始化

(5)
要使const变量能够在其他的文件中访问，必须显式地指定它为extern

(6)
引用只是对象的另一名字。当引用初始化后，只要改引用存在，它就保持绑定到初始化时指向的对象，不可能将引用绑定到另一个对象。
a reference must be initialized, and the initalizer must be an object.

(7)

``` c++
double dval = 3.14
const int &ri = dval;
```

编译器把这些代码转换成如下形式的编码

``` c++
int temp = dval;
const int &ri = temp;
```

(8)
头文件用于声明而不是用于定义，以下语句不能放在头文件中

``` c++
extern int ival = 1; //initializer
double xxx; //no extern
```

通常，头文件中只定义确实必要的东西

(9)
作用域操作符::，含义是右操作数的名字可以在做操作数的作用域中找到

(10)
getline(cin, line); getline 遇到换行符停止读入并返回，换行符不会存储在string对象中

(11)
string对象赋值

``` c++
string st1, st2 = "xxxxx";
st1 = st2;
```

先把st1占用的相关内存释放掉，然后再分配给st1足够存放st2副本的内存空间，最后把st2中所有字符复制到新分配的内存空间。

(12)
string 下标值，虽然任何整型都可以作索引，但索引的实际数据类型是unsigned类型string::size\_type

(13)
vector是一个类模板(class template)

(14)
编译器遇到内联函数就会直接扩展相应代码，而不是进行实际的函数调用。像vector.size()这样的小库函数几乎都定义为内联函数

(15)
除了下标，可以使用迭代器iterator访问vector元素。每个容器都定义了一个名为iterator的类型。迭代器可以解引用和自增(指向下一元素)。迭代器还可以做算术操作。iter + n, iter -n, iter2 - iter1

(16)
**任何改变vector长度的操作都会使已存在的迭代器失效。如push\_back() 和 erase()**

(17)
取地址符只能用于左值，因为只有当变量用作左值时，才能取其地址。

(18)
c++语言无法检测指针是否未被初始化，也无法区分有效地址和指针分配的存储空间中存放的二进制位形成的地址。
除非所指向的对象已经存在，否则不要先定义指针。如果必须分开定义指针和其所指的对象，则将指针初始化为0，因为编译器可以检测出0值的指针，程序可判断改指针并未指向一个对象。

(19)
void\* 只支持操作：与另一个指针进行比较，向函数传递void\*指针或从函数返回void\*指针，给另一个void\*赋值
不允许使用void\*指针操作它所指向的对象

(20)
指针和引用的比较：
第一个区别在于引用总是指向某个对象，定义引用时没有初始化时错误的。
第二个区别则是赋值行为的差异，给引用赋值修改的是改引用所关联的对象的值，而不是使引用于另一个对象关联。

(21)
在表达式中使用数组名时，该名字会自动转换为指向数组第一个元素的指针。

(22)
前置++操作需要做的工作更少，只需加1后返回加1的结果即可。而后置操作符则必须先保存操作数原来的值(创建一份拷贝)。养成使用前置操作这个好习惯，就不必操心性能差异的问题。

(23)
c++保证删除0值的指针是安全的。
删除指针后，该指针变成了悬垂指针。悬垂指针执行曾经存放对象的内存，但该对象已经不再存在了。
一般delete后对指针赋值NULL
注意当两个指针指向同一个动态创建的对象，删除时就会发生错误。如果在其中一个指针上做delete运算，将该对象的内存空间返回给自由存储区，然后接着delete第二个指针，此时自由存储区可能会被破坏。

(24)
在赋值过程中，因为不能更改左操作数对象的类型，因此左操作数的类型占主导地位。

(25)
隐式转换，注意用作条件的表达式被转换成bool类型

``` c++
int val;
if(val)   //val converted to bool
while(cin) //cin converted to bool
```

(26)
算术转换，最简单的算术转换是整型提升，转换规则需保护操作数的精度

(27)
其他隐式转换

**指针转换**，使用数组时，大多数情况下数组都会自动转换为指向第一个元素的指针，不将数组转换为指针的例外情况有：数组用做取地址&操作符的操作数或sizeof操作符的操作数时，或用数组对数组的引用进行初始化时，不会将数组转换为指针。C++还提供了另外两种指针转换，指向任意数据类型的指针都可转换为void*类型，整型数值常量0可以转换为任意指针类型。

**转换与枚举类型**，c++自动将枚举类型的对象或者枚举成员(enumerator)转换为整型，其转换结果可用于任何要求使用整数值的地方，比如

``` c++
// point2d is 2, point2w is 3, point3d is 3, point3w is 4
enum Points { point2d = 2, point2w, point3d = 3, point3w };
```

由标准库类型定义的转换，如

``` c++
string s;
while(cin >> s)
```

这里隐式使用了IO标准库定义的类型转换，无论读取是否成功，改表达式的结果都是cin。将istream类型转换为bool类型意味着要检验流的状态。如果最后一次读cin的尝试是成功的，则流的状态将导致上述类型转换为bool类型后获得true值。

(28)
显式转换
**const_cast**,将转换掉表达式的const属性，只有使用const_cast才能将const性质转换掉。在这种情况下，试图使用其他三种形式的强制转换都会导致编译时错误。类似的，除了添加或删除const特性，用const_cast符来执行其他任何类型转换，都会引起编译错误。

**static_cast**, 编译器隐式执行的任何类型转换都可以由static_cast显式完成。对于一个较大的算术类型到一个较小类型的赋值，编译器通常会产生警告。当我们显式地提供强制类型转换时，警告信息会被关闭。

**reinterpret_cast**, 通常为操作数的位模式提供较低层次的重新解释。reinterpret_cast本质上依赖机器，为了安全地使用reinterpret_cast, 要求程序员完全理解所涉及的数据类型，以及编译器实现强制类型转换的细节。

